//======================================================================
// fsm.a65
// -------
// FSM implementation for the fade-out function.
//
// The code uses the following zero page addresses:
// 02 as counter for memcpy routine.
// f8-f9 as ptr to the screen. Source for search, copy, folding.
// fa-fb as ptr to the low byte table
// fc-fd as ptr to the high byte table
// fe-ff as ptr to the screen. Destination for copy, folding.
//
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Defines
//------------------------------------------------------------------
.label screen_start = $0400
.label screen_end   = $07e7
.label screen_base  = $0772
.label char_rom     = $d000
.label char_copy    = $3800

.const state_init   = 1
.const state_next   = 2
.const state_update = 3
.const state_modify = 4
.const state_done   = 5

.const init_delay   = 10
.const fold_steps   = 4
.const fold_delay   = 10
.const fold_chars   = 4
.const test_chars   = 20


//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	        :BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
* = $0900     "Fsm test code"
start:
                // Scan to get track of all chars on the screen.
                jsr init_char_ptrs
                jsr init_screen_ptr
                jsr init_char_ctr
                jsr find_screen_chars

                // Change to lower case letters.
                lda $d018
                ora #$02
                sta $d018
                jsr print_state

more_chars:
                jsr wait_space
                jsr wait_time
                ldx #$00
mc1:
                jsr fsm_update
                inx
                cpx #fold_chars
                bne mc1

                jsr print_state
                lda active_chars
                bne more_chars
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
print_state:
                ldx #$00
print_more:
                lda fsm_state, x
                clc
                adc #$30
                sta screen_base, x

                lda fsm_delay_ctr, x
                clc
                adc #$30
                sta screen_base + $28, x

                lda fsm_fold_ctr, x
                clc
                adc #$30
                sta screen_base + $50, x

                inx
                cpx #$04
                bne print_more

                lda screen_char_ctr
                sta screen_base + $10
                lda screen_char_ctr + 1
                sta screen_base + $11

                lda $fa
                sta screen_base + $14
                lda $fb
                sta screen_base + $15

                lda $fc
                sta screen_base + $18
                lda $fd
                sta screen_base + $19

                lda active_chars
                clc
                adc #$30
                sta screen_base + $20
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
wait_space:
                lda #$7f
                sta $dc00
                lda $dc01
                and #$10
                bne wait_space
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
wait_time:
                dec wait
                lda wait
                beq wait1
                jmp wait_time
wait1:
                dec wait + 1
                lda wait + 1
                beq wait2
                jmp wait_time
wait2:
                lda #$01
                sta wait + 1
                rts

wait:
.byte $00, $00

//------------------------------------------------------------------
// State and counters for the FSM.
//------------------------------------------------------------------
* = $0f00 "FSM state."

active_chars:
.byte fold_chars

char_ctr:
.byte test_chars

fsm_state:
.byte state_init, state_init
.byte state_init, state_init

fsm_delay_ctr:
.byte init_delay + 0, init_delay + 3
.byte init_delay + 6, init_delay + 9

fsm_char_ptr_low:
.byte $00, $00, $00, $00

fsm_char_ptr_high:
.byte $00, $00, $00, $00

fsm_mod_char:
.byte $fb, $fc, $fd, $fe

fsm_fold_ctr:
.byte $00, $00, $00, $00

fold_chars_ctr:
.byte $04

screen_chars_done:
.byte $00

//------------------------------------------------------------------
//------------------------------------------------------------------
* = $1000 "FSM code."


//------------------------------------------------------------------
// fsm_update
// Perform the fsm update logic. Basically check state and
// jump to corresponding state handler.
//------------------------------------------------------------------
fsm_update:
                lda fsm_state, x
                cmp #state_init
                bne not_init
                jmp fsm_state_init
not_init:
                cmp #state_next
                bne not_next
                jmp fsm_state_next
not_next:
                cmp #state_update
                bne not_update
                jmp fsm_state_update
not_update:
                cmp #state_modify
                bne not_modify
                jmp fsm_state_modify
not_modify:
                cmp #state_done
                bne not_done
                jmp fsm_state_done
not_done:
                rts


//------------------------------------------------------------------
// fsm_state_init
// Initial state of fsm. Wait a delay number of iterations.
//------------------------------------------------------------------
fsm_state_init:
                dec fsm_delay_ctr, x
                bne fsi1
                lda #state_next
                sta fsm_state, x
fsi1:
                rts

//------------------------------------------------------------------
// fsm_state_next
// We should try to grab the next char to modify unless done.
//------------------------------------------------------------------
fsm_state_next:
                lda screen_chars_done
                beq fsn1
                dec active_chars
                lda #state_done
                sta fsm_state, x
                rts
fsn1:
                lda #state_update
                sta fsm_state, x
                rts


//------------------------------------------------------------------
// fsm_state_update
// There is at least one more char. Update the char pointers etc.
//------------------------------------------------------------------
fsm_state_update:
                jsr get_next_char
                lda #fold_delay
                sta fsm_delay_ctr, x
                lda #fold_steps
                sta fsm_fold_ctr, x
                lda #state_modify
                sta fsm_state, x
                rts

//------------------------------------------------------------------
// fsm_state_modify
// Perform the actual char modification operation
// When all steps has been performed we replace the mod char
// with a space.
//------------------------------------------------------------------
fsm_state_modify:
                dec fsm_delay_ctr, x
                beq fsm1
                rts
fsm1:
                dec fsm_fold_ctr, x
                beq fsm2
                jsr fold_char
                lda #fold_delay
                sta fsm_delay_ctr, x
                rts
fsm2:
                jsr remove_char
                lda #state_next
                sta fsm_state, x
                rts

//------------------------------------------------------------------
// fsm_state_done
// All chars has been processed. We are done.
//------------------------------------------------------------------
fsm_state_done:
                dec $d020
                rts

//------------------------------------------------------------------
// get_next_char
// Dummy code for getting the char pointed to by the char_ptr,
// checking which char it is, copy its definition to the fold
// char definition and replacing it with the fold char.
// This will also cause the char counter to decreas and
// Moving the next char pointer.
//------------------------------------------------------------------
get_next_char:
                jsr inc_char_ptrs
                jsr dec_char_ctr
                rts

//------------------------------------------------------------------
// fold_char
// Dummy code that simulates the actual char manipulation.
//------------------------------------------------------------------
fold_char:
                rts

//------------------------------------------------------------------
// fold_char
// Dummy code that should remove the mod char on the screen.
//------------------------------------------------------------------
remove_char:
                rts

//------------------------------------------------------------------
// find_screen_chars
//
// Scans the screen for all chars not being space (0x20). The
// 16-but address for each non space char is stored in two tables.
// The number of non space characters are also counted.
//------------------------------------------------------------------
find_screen_chars:
                ldy #$00
find_loop:
                lda ($f8), y
                cmp #$20
                beq next_char

                // Char is not space and we should store
                // its address in the tables, update table
                // pointers, and increase the char counter.
                lda $f8
                sta ($fa), y
                lda $f9
                sta ($fc), y

                jsr inc_char_ptrs
                jsr inc_char_ctr
next_char:
                lda $f9
                cmp #>screen_end
                bne notdone
                lda $f8
                cmp #<screen_end
                bne notdone
                rts
notdone:
                inc $f8
                bne find_loop
                inc $f9
                jmp find_loop

//------------------------------------------------------------------
//------------------------------------------------------------------
init_char_ptrs:
                lda #<char_ptr_low
                sta $fa
                lda #>char_ptr_low
                sta $fb

                lda #<char_ptr_high
                sta $fc
                lda #>char_ptr_high
                sta $fd
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
inc_char_ptrs:
                inc $fa
                bne inc_fc_fd
                inc $fb
inc_fc_fd:
                inc $fc
                bne no_inc_fd
                inc $fd
no_inc_fd:      rts

//------------------------------------------------------------------
//------------------------------------------------------------------
init_screen_ptr:
                lda #<screen_start
                sta $f8
                lda #>screen_start
                sta $f9
                rts

//------------------------------------------------------------------
// update_screen_ptr
// Update the screen pointer to the next char pointed to by
// the zp pointers into the screen pointer tables
//------------------------------------------------------------------
update_screen_ptr:
                ldy #$00
                lda ($fa), y
                sta $f8
                lda ($fc), y
                sta $f9
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
init_char_ctr:
                lda #$00
                sta screen_char_ctr
                sta screen_char_ctr + 1
                sta screen_chars_done
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
inc_char_ctr:
                inc screen_char_ctr
                bne icc1
                inc screen_char_ctr + 1
icc1:
                rts


//------------------------------------------------------------------
// dec_char_ctr:
//------------------------------------------------------------------
dec_char_ctr:   dec screen_char_ctr
                bne dcc1
                rts
dcc1:
                dec screen_char_ctr + 1
                beq dcc2
                rts
dcc2:
                lda #$01
                sta screen_chars_done
                rts

//------------------------------------------------------------------
// Pointer tables
// Screen char address pointer low bytes
// Screen char address pointer high bytes
//------------------------------------------------------------------
* = $2f00     "Char counter."
screen_char_ctr:
.byte $00, $00


* = $3000     "Pointer Tables."
char_ptr_low:
.fill 1024, 0

char_ptr_high:
.fill 1024, 0

//======================================================================
// EOF fsm.a65
//======================================================================
