//======================================================================
// fsm.a65
// -------
// FSM implementation.
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Defines
//------------------------------------------------------------------
.label state_init   = 1
.const state_next   = 2
.const state_update = 3
.const state_modify = 4
.const state_done   = 5

.const init_delay = 10
.const fold_steps = 4
.const fold_delay = 10
.const fold_chars = 4
.const test_chars = 20

//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	        :BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
* = $0900     "FSM test code"
start:
                // Change to lower case letters.
                lda $d018
                ora #$02
                sta $d018
                jsr print_state

more_chars:
                jsr wait_space
                jsr wait_time
                ldx #$00
mc1:
                jsr fsm_update
                inx
                cpx #fold_chars
                bne mc1

                jsr print_state
                lda active_chars
                bne more_chars
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
print_state:
                ldx #$00
print_more:
                lda fsm_state, x
                clc
                adc #$30
                sta $0400, x

                lda fsm_delay_ctr, x
                clc
                adc #$30
                sta $0428, x

                lda fsm_fold_ctr, x
                clc
                adc #$30
                sta $0450, x

                inx
                cpx #$04
                bne print_more

                lda char_ctr
                clc
                adc #$30
                sta $0410

                lda active_chars
                clc
                adc #$30
                sta $0411
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
wait_space:
                lda #$7f
                sta $dc00
                lda $dc01
                and #$10
                bne wait_space
                rts

//------------------------------------------------------------------
//------------------------------------------------------------------
wait_time:
                dec wait
                lda wait
                beq wait1
                jmp wait_time
wait1:
                dec wait + 1
                lda wait + 1
                beq wait2
                jmp wait_time
wait2:
                lda #$20
                sta wait + 1
                rts

wait:
.byte $00, $00

//------------------------------------------------------------------
// State and counters for the FSM.
//------------------------------------------------------------------
* = $0f00 "FSM state."

active_chars:
.byte fold_chars

char_ctr:
.byte test_chars

fsm_state:
.byte state_init, state_init
.byte state_init, state_init

fsm_delay_ctr:
.byte init_delay + 0, init_delay + 1
.byte init_delay + 2, init_delay + 3

fsm_fold_ctr:
.byte $00, $00, $00, $00


//------------------------------------------------------------------
//------------------------------------------------------------------
* = $1000 "FSM code."


//------------------------------------------------------------------
// fsm_update
// Perform the fsm update logic. Basically check state and
// jump to corresponding state handler.
//------------------------------------------------------------------
fsm_update:
                lda fsm_state, x
                cmp #state_init
                bne not_init
                jmp fsm_state_init
not_init:
                cmp #state_next
                bne not_next
                jmp fsm_state_next
not_next:
                cmp #state_update
                bne not_update
                jmp fsm_state_update
not_update:
                cmp #state_modify
                bne not_modify
                jmp fsm_state_modify
not_modify:
                cmp #state_done
                bne not_done
                jmp fsm_state_done
not_done:
                rts


//------------------------------------------------------------------
// fsm_state_init
// Initial state of fsm. Wait a delay number of iterations.
//------------------------------------------------------------------
fsm_state_init:
                dec fsm_delay_ctr, x
                bne fsi1
                lda #state_next
                sta fsm_state, x
fsi1:
                rts

//------------------------------------------------------------------
// fsm_state_next
// We should try to grab the next char to modify unless done.
// TODO: Add decrease of active chars here.
//------------------------------------------------------------------
fsm_state_next:
                lda char_ctr
                bne fsn1
                dec active_chars
                lda #state_done
                sta fsm_state, x
                rts
fsn1:
                lda #state_update
                sta fsm_state, x
                rts


//------------------------------------------------------------------
// fsm_state_update
// There is at least one more char. Update the char pointers etc.
//------------------------------------------------------------------
fsm_state_update:
                jsr get_next_char
                lda #fold_delay
                sta fsm_delay_ctr, x
                lda #fold_steps
                sta fsm_fold_ctr, x
                lda #state_modify
                sta fsm_state, x
                rts

//------------------------------------------------------------------
// fsm_state_modify
// Perform the actual char modification operation
//------------------------------------------------------------------
fsm_state_modify:
                dec fsm_delay_ctr, x
                beq fsm1
                rts
fsm1:
                dec fsm_fold_ctr, x
                beq fsm2
                jsr fold_char
                lda #fold_delay
                sta fsm_delay_ctr, x
                rts
fsm2:
                lda #state_next
                sta fsm_state, x
                rts

//------------------------------------------------------------------
// fsm_state_done
// All chars has been processed. We are done.
//------------------------------------------------------------------
fsm_state_done:
                dec $d020
                rts

//------------------------------------------------------------------
// get_next_char
// Dummy code for getting the char pointed to by the char_ptr,
// checking which char it is, copy its definition to the fold
// char definition and replacing it with the fold char.
// This will also cause the char counter to decreas and
// Moving the next char pointer.
//------------------------------------------------------------------
get_next_char:
                dec char_ctr
                rts

//------------------------------------------------------------------
// fold_char
// Dummu code that simulates the actual char manipulation.
//------------------------------------------------------------------
fold_char:
                rts
